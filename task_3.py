# -*- coding: utf-8 -*-
"""Task_3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17n1dww5LWTeZKFr-5xk8SC08ZPp2QQAm
"""

import os
import numpy as np
from PIL import Image
from tqdm import tqdm
import numpy as np
import tensorflow as tf
import matplotlib.pyplot as plt

# from google.colab import drive
# drive.mount('/content/drive', force_remount=True)

"""## Create Dataset from JPEG

The dataset are downloaded from https://www.kaggle.com/datasets/splcher/animefacedataset, origionally made by https://github.com/bchao1/Anime-Face-Dataset.
"""

# Step 1: Get all jpg image files in the dataset folder
image_files = [f for f in os.listdir("anime_faces_dataset/") if f.endswith(".jpg")]

# Placeholder list to hold processed images
images_list = []

for image_file in image_files:
    # Step 2a: Load the image using PIL
    img_path = os.path.join("anime_faces_dataset/", image_file)
    with Image.open(img_path) as img:
        # Step 2b: Resize the image to 64x64
        img_resized = img.resize((64, 64))

        # Convert image to numpy array
        img_array = np.array(img_resized)

        # Step 2c: Rescale the image (normalize pixel values to [0, 1])
        # img_rescaled = img_array / 255.0

        images_list.append(img_array)

# Step 3: Stack all processed images into a single numpy array
dataset = np.stack(images_list, axis=0)

# Step 4: Save the numpy array to a ".npy" file
np.save("anime_faces.npy", dataset)

"""## Read Dataset"""

def load_real_samples(scale=False):
    # We load 10,000 samples only to avoid memory issues, you can  change this value
    X = np.load("drive/MyDrive/anime_faces.npy")[:10000, :, :, :]
    # Scale samples in range [-127, 127]
    if scale:
        X = (X - 127.5) * 2
    return X / 255.0


# We will use this function to display the output of our models throughout this notebook
def grid_plot(
    images,
    epoch="",
    name="",
    n=3,
    save=False,
    scale=False,
    method="",
    figtype="generated",
    show = True,
):
    if scale:
        images = (images + 1) / 2.0
    for index in range(n * n):
        plt.subplot(n, n, 1 + index)
        plt.axis("off")
        plt.imshow(images[index])
    fig = plt.gcf()
    fig.suptitle(name + "  " + str(epoch), fontsize=14)
    if save:
        filedir = f"drive/MyDrive/{method}_generated_figures/"
        if figtype == "generated":
            filename = "generated_figure_e%03d_f.png" % (epoch + 1)
        elif figtype == "original":
            filename = "origional_figure_e%03d_f.png" % (epoch + 1)
        plt.savefig(filedir + filename)
        plt.close()
    if show:
      plt.show()


dataset = load_real_samples()
grid_plot(dataset[np.random.randint(0, 1000, 9)], name="Fliqr dataset (64x64x3)", n=3)

"""## Code for building Down/Up sampling"""

from tensorflow.keras.layers import Dense, Flatten, Conv2D, Conv2DTranspose, Reshape


def build_conv_net(
    in_shape, out_shape, n_downsampling_layers=4, filters=128, out_activation="sigmoid"
):
    """
    Build a basic convolutional network
    """
    model = tf.keras.Sequential()
    default_args = dict(
        kernel_size=(3, 3), strides=(2, 2), padding="same", activation="relu"
    )

    model.add(Conv2D(input_shape=in_shape, **default_args, filters=filters))

    for _ in range(n_downsampling_layers):
        model.add(Conv2D(**default_args, filters=filters))

    model.add(Flatten())
    model.add(Dense(out_shape, activation=out_activation))
    model.summary()
    return model


def build_deconv_net(
    latent_dim, n_upsampling_layers=4, filters=128, activation_out="sigmoid"
):
    """
    Build a deconvolutional network for decoding/upscaling latent vectors

    When building the deconvolutional architecture, usually it is best to use the same layer sizes that
    were used in the downsampling network and the Conv2DTranspose layers are used instead of Conv2D layers.
    Using identical layers and hyperparameters ensures that the dimensionality of our output matches the
    shape of our input images.
    """

    model = tf.keras.Sequential()
    model.add(Dense(4 * 4 * 64, input_dim=latent_dim))
    model.add(
        Reshape((4, 4, 64))
    )  # This matches the output size of the downsampling architecture
    default_args = dict(
        kernel_size=(3, 3), strides=(2, 2), padding="same", activation="relu"
    )

    for i in range(n_upsampling_layers):
        model.add(Conv2DTranspose(**default_args, filters=filters))

    # This last convolutional layer converts back to 3 channel RGB image
    model.add(
        Conv2D(filters=3, kernel_size=(3, 3), activation=activation_out, padding="same")
    )
    model.summary()
    return model

"""### Convolutional Autoencoder Example"""

def build_convolutional_autoencoder(data_shape, latent_dim, filters=128):
    encoder = build_conv_net(in_shape=data_shape, out_shape=latent_dim, filters=filters)
    decoder = build_deconv_net(latent_dim, activation_out="sigmoid", filters=filters)

    # We connect encoder and decoder into a single model
    autoencoder = tf.keras.Sequential([encoder, decoder])

    # Binary crossentropy loss - pairwise comparison between input and output pixels
    autoencoder.compile(loss="binary_crossentropy", optimizer="adam")

    return autoencoder


# Defining the model dimensions and building it
image_size = dataset.shape[1:]
latent_dim = 512
num_filters = 128
cae = build_convolutional_autoencoder(image_size, latent_dim, num_filters)

for epoch in range(50):
    print("\nEpoch: ", epoch)

    # Note that (X=y) when training autoencoders!
    # In this case we only care about qualitative performance, we don't split into train/test sets
    cae.fit(x=dataset, y=dataset, epochs=1, batch_size=64)

    samples = dataset[:9]
    reconstructed = cae.predict(samples)
    grid_plot(
        samples,
        epoch,
        name="Original",
        n=3,
        save=True,
        figtype="original",
        method="CAE",
    )
    grid_plot(
        reconstructed,
        epoch,
        name="Reconstructed",
        n=3,
        save=True,
        figtype="generated",
        method="CAE",
    )

"""## Variational Autoencoders (VAEs)"""

class Sampling(tf.keras.layers.Layer):
    """
    Custom layer for the variational autoencoder
    It takes two vectors as input - one for means and other for variances of the latent variables described by a multimodal gaussian
    Its output is a latent vector randomly sampled from this distribution
    """

    def call(self, inputs):
        z_mean, z_var = inputs
        batch = tf.shape(z_mean)[0]
        dim = tf.shape(z_mean)[1]
        epsilon = tf.keras.backend.random_normal(shape=(batch, dim))
        return z_mean + tf.exp(0.5 * z_var) * epsilon


def build_vae(data_shape, latent_dim, filters=128):
    # Building the encoder - starts with a simple downsampling convolutional network
    encoder = build_conv_net(data_shape, latent_dim * 2, filters=filters)

    # Adding special sampling layer that uses the reparametrization trick
    z_mean = Dense(latent_dim)(encoder.output)
    z_var = Dense(latent_dim)(encoder.output)
    z = Sampling()([z_mean, z_var])

    # Connecting the two encoder parts
    encoder = tf.keras.Model(inputs=encoder.input, outputs=z)

    # Defining the decoder which is a regular upsampling deconvolutional network
    decoder = build_deconv_net(latent_dim, activation_out="sigmoid", filters=filters)
    vae = tf.keras.Model(inputs=encoder.input, outputs=decoder(z))

    # Adding the special loss term
    kl_loss = -0.5 * tf.reduce_sum(z_var - tf.square(z_mean) - tf.exp(z_var) + 1)
    vae.add_loss(kl_loss / tf.cast(tf.keras.backend.prod(data_shape), tf.float32))

    vae.compile(
        optimizer=tf.keras.optimizers.Adam(learning_rate=1e-3),
        loss="binary_crossentropy",
    )

    return encoder, decoder, vae

# Training the VAE model

latent_dim = 512
batch_size = 6
encoder, decoder, vae = build_vae(dataset.shape[1:], latent_dim, filters=128)

# Generate random vectors that we will use to sample our latent space
for epoch in range(300):
    latent_vectors = np.random.randn(9, latent_dim)
    vae.fit(x=dataset, y=dataset, epochs=1, batch_size=batch_size)

    images = decoder(latent_vectors)
    grid_plot(
        images,
        epoch,
        name=f"VAE generated images ({latent_dim}D, {batch_size}BS)",
        n=3,
        save=True,
        method="VAE",
        figtype="generated",
        show = False,
    )

"""### Visulatize the linear changes between two points of VAE."""

def interpolate_points(p1, p2, n_steps=10):
    # Compute the linearly interpolated vectors
    # create a linspace with n_steps elements between 0 and 1
    ratios = np.linspace(0, 1, num=n_steps)
    vectors = list()
    for ratio in ratios:
        # implement the interpolation formula
        v = (1.0 - ratio) * p1 + ratio * p2
        vectors.append(v)
    vectors = np.asarray(vectors)  # make the vectors a numpy array
    # return the reshaped vectors array in accordance with the input required by the decoder
    return vectors.reshape(vectors.shape[0], latent_dim)

## define a function to plot the changes in the latent space
def flexible_grid_plot(
    images,
    x,
    y,
    name="",
    save=False,
    scale=False,
    method="",
    show=True,
):
    if scale:
        images = (images + 1) / 2.0

    plt.figure(figsize=(y, x))

    for index in range(x * y):
        plt.subplot(x, y, 1 + index)
        plt.axis("off")
        if index < len(images):  # Only plot if there's an image left to plot
            plt.imshow(images[index])
        else:
            plt.axis("off")  # Turn off axes for any remaining subplots

    fig = plt.gcf()
    fig.suptitle(name, fontsize=14)

    if save:
        filedir = "drive/MyDrive"
        filename = f"{method}_output_changes.png"
        plt.savefig(filedir + filename)
        plt.close()
    if show:
        plt.show()


# 1. Generate two random latent vectors
point1 = np.random.randn(1, latent_dim)
point2 = np.random.randn(1, latent_dim)

# 2. Linearly interpolate between the two points
interpolated = interpolate_points(point1, point2, n_steps=20)

# 3. Decode the interpolated vectors to generate images
interpolated_images = decoder(interpolated)

# 4. Visualize the generated images
flexible_grid_plot(
    interpolated_images,
    x=2,
    y=10,
    name="VAE linear changes between two random latent vectors",
)

"""## Generative Adversarial Networks (GANs)"""

def build_gan(data_shape, latent_dim, filters=128, lr=0.0002, beta_1=0.5):
    #optimizer = tf.optimizers.Adam(learning_rate=lr, beta_1=beta_1)
    # have to change the optimizer to aviod bugs
    optimizer = tf.keras.optimizers.legacy.Adam(learning_rate=lr, beta_1=beta_1)

    # Usually thew GAN generator has tanh activation function in the output layer
    generator = build_deconv_net(latent_dim, activation_out="tanh", filters=filters)

    # Build and compile the discriminator
    discriminator = build_conv_net(
        in_shape=data_shape, out_shape=1, filters=filters
    )  # Single output for binary classification
    discriminator.compile(loss="binary_crossentropy", optimizer=optimizer)

    # End-to-end GAN model for training the generator
    discriminator.trainable = False
    true_fake_prediction = discriminator(generator.output)
    GAN = tf.keras.Model(inputs=generator.input, outputs=true_fake_prediction)
    GAN = tf.keras.models.Sequential([generator, discriminator])
    GAN.compile(loss="binary_crossentropy", optimizer=optimizer)

    return discriminator, generator, GAN

def run_generator(generator, n_samples=100):
    """
    Run the generator model and generate n samples of synthetic images using random latent vectors
    """
    latent_dim = generator.layers[0].input_shape[-1]
    generator_input = np.random.randn(n_samples, latent_dim)

    return generator.predict(generator_input)


def get_batch(generator, dataset, batch_size=64):
    """
    Gets a single batch of samples (X) and labels (y) for the training the discriminator.
    One half from the real dataset (labeled as 1s), the other created by the generator model (labeled as 0s).
    """
    batch_size //= 2  # Split evenly among fake and real samples

    fake_data = run_generator(generator, n_samples=batch_size)
    real_data = dataset[np.random.randint(0, dataset.shape[0], batch_size)]

    X = np.concatenate([fake_data, real_data], axis=0)
    y = np.concatenate([np.zeros([batch_size, 1]), np.ones([batch_size, 1])], axis=0)

    return X, y


def train_gan(
    generator, discriminator, gan, dataset, latent_dim, n_epochs=20, batch_size=64
):
    batches_per_epoch = int(dataset.shape[0] / batch_size / 2)
    for epoch in range(n_epochs):
        for batch in tqdm(range(batches_per_epoch)):
            # 1) Train discriminator both on real and synthesized images
            X, y = get_batch(generator, dataset, batch_size=batch_size)
            discriminator_loss = discriminator.train_on_batch(X, y)

            # 2) Train generator (note that now the label of synthetic images is reversed to 1)
            X_gan = np.random.randn(batch_size, latent_dim)
            y_gan = np.ones([batch_size, 1])
            generator_loss = gan.train_on_batch(X_gan, y_gan)

        noise = np.random.randn(16, latent_dim)
        images = generator.predict(noise)
        grid_plot(
            images, epoch, name="GAN generated images", n=3, save=True, scale=True, method = 'GAN', figtype= 'generated', show=True
        )

# Build and train the model (need around 10 epochs to start seeing some results)

latent_dim = 512
discriminator, generator, gan = build_gan(dataset.shape[1:], latent_dim, filters=128)
dataset_scaled = load_real_samples(scale=True)

train_gan(generator, discriminator, gan, dataset_scaled, latent_dim, n_epochs=200)

# 1. Generate two random latent vectors
point1 = np.random.randn(1, latent_dim)
point2 = np.random.randn(1, latent_dim)

# 2. Linearly interpolate between the two points
interpolated = interpolate_points(point1, point2, n_steps=20)

# 3. Decode the interpolated vectors to generate images
interpolated_images = generator(interpolated)

# 4. Visualize the generated images
flexible_grid_plot(
    interpolated_images,
    x=2,
    y=10,
    name="GAN linear changes between two random latent vectors",scale = True
)

